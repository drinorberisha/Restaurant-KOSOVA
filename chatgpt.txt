Step 1: Setting Up the API Endpoints

    Product Listing API: Retrieves a list of all menu items and their inventory details.
        Endpoint: GET /api/inventory
        Server Function: Fetches data from both MenuItems and Inventory tables.

    Stock Adjustment API: Updates the stock count for a specific inventory item.
        Endpoint: POST /api/inventory/update
        Server Function: Updates the current_count in the Inventory table.

    Search and Filter API: Allows searching and filtering of inventory items.
        Endpoint: GET /api/inventory/search
        Server Function: Performs query based on search parameters against MenuItems and Inventory.

    Stock Alerts API: Checks for items below minimum required stock.
        Endpoint: GET /api/inventory/alerts
        Server Function: Retrieves items from Inventory where current_count < minimum_required.

    Historical Data API: Fetches historical data for inventory and order items.
        Endpoint: GET /api/inventory/history
        Server Function: Queries OrderItems and Orders for past data.

    User Access Level Control: Manages access based on user roles.
        Use roles defined in the users table to control access to different API endpoints.

    Audit Trail: Logs changes made to inventory.
        Could involve a new table for logging or a mechanism within each relevant API endpoint to record changes.

    Integration with Ordering System: Syncs with the restaurant ordering system.
        This might involve creating APIs that align with the functionalities of your existing ordering system, particularly regarding updating Orders and OrderItems.

Step 2: Implementing Server Functions

For each endpoint, implement a server function in your backend (Node.js, Express.js, or similar) that executes the required SQL queries. Use SQLite's features to ensure data integrity and handle transactions where necessary.
Step 3: Frontend Integration.
3.1 Product Listing Page

    Create a React component that fetches and displays inventory data.
    Use GET /api/inventory to retrieve and display product information.
    Include UI elements for stock adjustments (plus/minus buttons).

3.2 Stock Adjustment Functionality

    Implement functionality to adjust stock levels on the frontend.
    When the stock is adjusted via plus/minus buttons, send a request to POST /api/inventory/update.
    Ensure real-time UI update after successful backend response.

3.3 Search and Filter Implementation

    Add search and filter input fields to the product listing page.
    Implement on-change events that send requests to GET /api/inventory/search.
    Display the filtered/queried results dynamically.

3.4 Stock Alerts Display

    Add a section or indicator for stock alerts (items below minimum stock).
    Fetch data using GET /api/inventory/alerts and display alerts appropriately.

3.5 Historical Data Visualization

    Create a component to display historical data.
    Fetch data using GET /api/inventory/history.
    Consider using tables or charts for better data representation.

3.6 User Access Level Implementation

    Implement user authentication and role-based access control on the frontend.
    Display different UI elements or pages based on the user's role.

3.7 Audit Trail Interface

    Create a section to view the audit logs (may require a new API endpoint if not covered in existing ones).
    Display the changes made, by whom, and when.

3.8 Ordering System Integration

    Develop components that interact with the ordering system.
    Ensure that order updates reflect in the inventory management system.


Step 4: Testing and Validation
4.1 API Endpoint Testing

    Unit Testing: Write unit tests for each server function to ensure they perform as expected. This involves testing SQL queries, response formats, error handling, etc.
    Endpoint Testing: Use tools like Postman or Insomnia to test each API endpoint. Ensure they handle requests correctly and return the expected responses.

4.2 Frontend Integration Testing

    Component Testing: Test each React component individually to ensure they render correctly and handle state changes as expected.
    Interaction Testing: Test the interactions between your frontend components and the API. This includes testing data fetching, form submissions, and real-time updates.

4.3 End-to-End Testing

    Workflow Testing: Simulate typical user workflows to test the system as a whole. This includes logging in, viewing inventory, adjusting stock levels, and checking alerts.
    Error Handling: Test how the system handles invalid inputs, network issues, and server errors.

4.4 User Access Level Testing

    Role-Based Testing: Test the application with different user roles to ensure that access controls are working correctly. Users should only be able to access and perform actions that their role permits.

4.5 Performance Testing

    Load Testing: Test how the system performs under heavy load, especially if you expect a large number of products or high usage.

4.6 Security Testing

    Vulnerability Assessment: Check for SQL injection vulnerabilities, proper authentication, and data encryption.

4.7 Compatibility and Responsiveness Testing

    Device and Browser Testing: Ensure the application is responsive and functions correctly across different devices and browsers.





It is working correctly now. Now based on the backend functions :"exports.deleteMenuItem = async (req, res) => {
    try {
        const { itemId } = req.params;
        await db('MenuItems').where('item_id', itemId).del();
        res.status(200).json({ message: 'Menu item deleted' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Error deleting menu item' });
    }
};

exports.editMenuItem = async (req, res) => {
    try {
        const { itemId } = req.params;
        const { item_name, price } = req.body;
        await db('MenuItems').where('item_id', itemId).update({ item_name, price });
        res.status(200).json({ message: 'Menu item updated' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Error updating menu item' });
    }
};
", implement also these 2 features the same way as this addProduct. Just a little bit different , add a button next to the plus and minus signs :"import React , {useState, useEffect} from 'react';
import AddProductForm from './AddProductForm';

const InventoryTable = () => {
  const [userRole, setUserRole] = useState(null);
  const [showAddForm, setShowAddForm] = useState(false); // State to control form visibility


  useEffect(() => {
    // Access localStorage only after the component has mounted
    const storedUserRole = localStorage.getItem('userRole');
    setUserRole(storedUserRole);
  }, []);
  const initialInventoryItems = [
    { id: 1, itemName: 'Margarita', category: 'Food', subcategory: 'Pizza', currentCount: 20, minimumRequired: 5 },
    { id: 2, itemName: 'Diavolo', category: 'Food', subcategory: 'Pizza', currentCount: 15, minimumRequired: 5 },
    { id: 3, itemName: 'Coke', category: 'Drinks', subcategory: 'Soft Drinks', currentCount: 30, minimumRequired: 10 },
    { id: 4, itemName: 'Cheesecake', category: 'Desserts', subcategory: 'Cake', currentCount: 15, minimumRequired: 5 },
    // More items...
  ];
  const [inventoryItems, setInventoryItems] = useState(initialInventoryItems);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterCategory, setFilterCategory] = useState('All');
  // Function to adjust stock
  const adjustStock = (itemId, adjustment) => {
    const updatedItems = inventoryItems.map(item => {
      if (item.id === itemId) {
        // Prevent stock from going negative
        const updatedCount = Math.max(item.currentCount + adjustment, 0);
        return { ...item, currentCount: updatedCount };
      }
      return item;
    });
    setInventoryItems(updatedItems);
  };
  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value.toLowerCase());
  };

  const handleCategoryChange = (e) => {
    setFilterCategory(e.target.value);
  };

  const filteredItems = inventoryItems.filter(item => {
    return (
      (filterCategory === 'All' || item.category === filterCategory) &&
      item.itemName.toLowerCase().includes(searchTerm)
    );
  });
  const isStockLow = (item) => {
    return item.currentCount < item.minimumRequired;
  };



  // Function to determine if the user can adjust stock
  const canAdjustStock = () => {
    if (!userRole) return false;
    // Define which roles are allowed to adjust stock
    const allowedRoles = ["manager", "admin"];
    return allowedRoles.includes(userRole);
  };



  const handleAddClick = () => {
    setShowAddForm(true); // Show the form
  };
  return (
    <>
     <div className="mb-4">
        <input
          type="text"
          placeholder="Search items..."
          onChange={handleSearchChange}
          className="mr-2"
        />
        <select onChange={handleCategoryChange}>
          <option value="All">All Categories</option>
          <option value="Food">Food</option>
          <option value="Drinks">Drinks</option>
          <option value="Desserts">Desserts</option>
          {/* Add more categories as needed */}
        </select>
        <button></button>
      </div>
    <table className="min-w-full table-auto">
      <thead>
        <tr>
          <th className="px-4 py-2 border">Item Name</th>
          <th className="px-4 py-2 border">Category</th>
          <th className="px-4 py-2 border">Subcategory</th>
          <th className="px-4 py-2 border">Current Count</th>
          <th className="px-4 py-2 border">Minimum Required</th>
          <th className="px-4 py-2 border">Actions</th>
        </tr>
      </thead>
      <tbody>
        {inventoryItems.map(item => (
            <tr key={item.id} className={isStockLow(item) ? "bg-red-100" : ""}>
            <td className="border px-4 py-2">{item.itemName}</td>
            <td className="border px-4 py-2">{item.category}</td>
            <td className="border px-4 py-2">{item.subcategory}</td>
            <td className="border px-4 py-2">{item.currentCount}</td>
            <td className="border px-4 py-2">{item.minimumRequired}</td>
            <td className="border px-4 py-2 ">
            {canAdjustStock() && (
                  <>
              <button className="border border-black mr-4"onClick={() => adjustStock(item.id, 1)}>+</button>
              <button className="border border-black "onClick={() => adjustStock(item.id, -1)}>-</button>
              </>
              )}
            </td>
          </tr>
        ))}
      </tbody>
    </table>
    {userRole === 'admin' && (
        <button onClick={handleAddClick} className="bg-blue-500 text-white p-2 rounded">
          Add New Product
        </button>
      )}

      {showAddForm && <AddProductForm setShowAddForm={setShowAddForm} />}
    </>
  );
};

export default InventoryTable;
",

